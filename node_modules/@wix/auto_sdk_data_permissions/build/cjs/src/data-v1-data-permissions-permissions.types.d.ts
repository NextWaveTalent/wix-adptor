/**
 * Permissions configuration of a data collection.
 *
 * Describes who can perform certain data operations on a collection.
 */
export interface DataPermissions {
    /**
     * Data Collection ID that is subject of these permissions
     * @immutable
     * @maxLength 255
     */
    id?: string;
    /** Access level for data items read */
    itemRead?: AccessLevelWithLiterals;
    /** Access level for data items insert */
    itemInsert?: AccessLevelWithLiterals;
    /** Access level for data items update */
    itemUpdate?: AccessLevelWithLiterals;
    /** Access level for data items removal */
    itemRemove?: AccessLevelWithLiterals;
}
/**
 * Describes who can perform certain action.
 * Each level includes all levels below it (except UNDEFINED).
 */
export declare enum AccessLevel {
    /** Not set */
    UNKNOWN = "UNKNOWN",
    /** Any subject, including visitors */
    ANYONE = "ANYONE",
    /** Any signed-in user (both site members and collaborators) */
    SITE_MEMBER = "SITE_MEMBER",
    /** Any signed-in user, but site members only have access to own items */
    SITE_MEMBER_AUTHOR = "SITE_MEMBER_AUTHOR",
    /** Site collaborator that has a role with CMS Access permission */
    CMS_EDITOR = "CMS_EDITOR",
    /** CMS administrators and users or roles granted with special access */
    PRIVILEGED = "PRIVILEGED"
}
/** @enumType */
export type AccessLevelWithLiterals = AccessLevel | 'UNKNOWN' | 'ANYONE' | 'SITE_MEMBER' | 'SITE_MEMBER_AUTHOR' | 'CMS_EDITOR' | 'PRIVILEGED';
/** Special access granted to user or role */
export interface SpecialPermissions extends SpecialPermissionsSubjectOneOf {
    /**
     * User ID that is subject of these permissions
     * @immutable
     * @maxLength 64
     */
    userId?: string;
    /**
     * Policy ID of (custom) role that is subject of these permissions
     * @immutable
     * @maxLength 64
     */
    policyId?: string;
    /**
     * ID of this special access, so it can be managed separately
     * @format GUID
     * @readonly
     */
    id?: string;
    /** If data item read is allowed */
    itemRead?: AccessWithLiterals;
    /** If data item insert is allowed */
    itemInsert?: AccessWithLiterals;
    /** If data item update is allowed */
    itemUpdate?: AccessWithLiterals;
    /** If data item remove is allowed */
    itemRemove?: AccessWithLiterals;
}
/** @oneof */
export interface SpecialPermissionsSubjectOneOf {
    /**
     * User ID that is subject of these permissions
     * @immutable
     * @maxLength 64
     */
    userId?: string;
    /**
     * Policy ID of (custom) role that is subject of these permissions
     * @immutable
     * @maxLength 64
     */
    policyId?: string;
}
export declare enum Access {
    /** Action is not specifically allowed, but can be allowed by top-level permissions */
    UNSPECIFIED = "UNSPECIFIED",
    /** Action is specifically allowed */
    ALLOWED = "ALLOWED"
}
/** @enumType */
export type AccessWithLiterals = Access | 'UNSPECIFIED' | 'ALLOWED';
export interface GetPermissionsRequest {
    /**
     * Data Collection ID to get permissions for
     * @maxLength 256
     */
    dataCollectionId: string;
}
export interface GetPermissionsResponse {
    /** Requested data permissions */
    dataPermissions?: DataPermissions;
}
export interface UpdatePermissionsRequest {
    /** Data permissions to update */
    dataPermissions: DataPermissions;
}
export interface UpdatePermissionsResponse {
    /** Updated data permissions */
    dataPermissions?: DataPermissions;
}
export interface AddSpecialPermissionsRequest {
    /**
     * Data Collection ID to add special permission for
     * @maxLength 256
     */
    dataCollectionId: string;
    /** Special permissions to add */
    specialPermissions: SpecialPermissions;
}
export interface AddSpecialPermissionsResponse {
    /** Added special data permissions */
    specialPermissions?: SpecialPermissions;
}
export interface UpdateSpecialPermissionsRequest {
    /** Special permissions to update */
    specialPermissions: SpecialPermissions;
}
export interface UpdateSpecialPermissionsResponse {
    /** Updated special data permissions */
    specialPermissions?: SpecialPermissions;
}
export interface RemoveSpecialPermissionsRequest {
    /**
     * Special permissions ID to remove
     * @format GUID
     */
    specialPermissionsId: string;
}
export interface RemoveSpecialPermissionsResponse {
}
export interface GetMyPermissionsRequest {
    /**
     * Data Collection ID to get permission for
     * @maxLength 256
     */
    dataCollectionId: string;
}
export interface GetMyPermissionsResponse {
    /** If data item read is allowed */
    itemRead?: boolean;
    /** If data item insert is allowed */
    itemInsert?: boolean;
    /** If data item update is allowed */
    itemUpdate?: boolean;
    /** If data item remove is allowed */
    itemRemove?: boolean;
}
export interface MigrateCustomRolesRequest {
    /**
     * Role ID to update, if empty updates all roles in scope
     * @format GUID
     */
    policyId?: string | null;
}
export interface MigrateCustomRolesResponse {
}
export interface PolicyAssignmentsUpdated extends PolicyAssignmentsUpdatedEventOneOf {
    policyAssigned?: PolicyAssigned;
    policyUnassigned?: PolicyUnassigned;
    policyAssignmentUpdated?: PolicyAssignmentUpdated;
}
/** @oneof */
export interface PolicyAssignmentsUpdatedEventOneOf {
    policyAssigned?: PolicyAssigned;
    policyUnassigned?: PolicyUnassigned;
    policyAssignmentUpdated?: PolicyAssignmentUpdated;
}
export interface PolicyAssigned {
    subject?: Subject;
    assignment?: PolicyAssignment[];
}
export interface Subject {
    /** ID of identity assigned to the asset. */
    id?: string;
    /** Type of identity assigned to the asset. Supported subject types include user IDs, account IDs, and app IDs. */
    subjectType?: SubjectTypeWithLiterals;
    /** Context of identity assigned to the asset. For example, a `subjectType` = `USER` will have `context` = `ACCOUNT`. */
    context?: SubjectContext;
}
export declare enum SubjectType {
    UNKNOWN = "UNKNOWN",
    ACCOUNT = "ACCOUNT",
    USER = "USER",
    USER_GROUP = "USER_GROUP",
    MEMBER_GROUP = "MEMBER_GROUP",
    VISITOR_GROUP = "VISITOR_GROUP",
    EXTERNAL_APP = "EXTERNAL_APP",
    ACCOUNT_GROUP = "ACCOUNT_GROUP",
    WIX_APP = "WIX_APP"
}
/** @enumType */
export type SubjectTypeWithLiterals = SubjectType | 'UNKNOWN' | 'ACCOUNT' | 'USER' | 'USER_GROUP' | 'MEMBER_GROUP' | 'VISITOR_GROUP' | 'EXTERNAL_APP' | 'ACCOUNT_GROUP' | 'WIX_APP';
export interface SubjectContext {
    id?: string;
    contextType?: SubjectContextTypeWithLiterals;
}
export declare enum SubjectContextType {
    UNKNOWN_CTX = "UNKNOWN_CTX",
    ORG_CTX = "ORG_CTX",
    ACCOUNT_CTX = "ACCOUNT_CTX"
}
/** @enumType */
export type SubjectContextTypeWithLiterals = SubjectContextType | 'UNKNOWN_CTX' | 'ORG_CTX' | 'ACCOUNT_CTX';
export interface PolicyAssignment {
    policyId?: string;
    resource?: ResourcePath;
    condition?: PolicyCondition;
    assignmentId?: string | null;
}
export interface ResourcePath {
    organization?: string | null;
    account?: string | null;
    site?: string | null;
    resource?: Resource;
}
/**
 * A custom resource. Is used to represent some asset that is not a direct resource context (site or account), but something custom.
 * For example: payment method, blog post, domain, logo.
 */
export interface Resource {
    /** The resource id. */
    id?: string | null;
    /** The resource type */
    type?: string | null;
}
export interface PolicyCondition {
    /** The type of the condition */
    condition?: ConditionType;
}
export interface ConditionType extends ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
/** @oneof */
export interface ConditionTypeOfOneOf {
    /** @deprecated */
    simpleCondition?: SimpleCondition;
    /** A logic combination between several conditions, with an operator between them */
    joinedConditions?: JoinedCondition;
    /** @deprecated */
    environmentCondition?: EnvironmentCondition;
    /** A single condition */
    condition?: Condition;
}
export interface SimpleCondition {
    attrName?: string;
    value?: SimpleConditionValue;
    op?: SimpleConditionOperatorWithLiterals;
    conditionModelId?: string;
}
export interface SimpleConditionValue extends SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
/** @oneof */
export interface SimpleConditionValueValueOneOf {
    attrName?: string;
    stringValue?: string;
    boolValue?: boolean;
}
export declare enum SimpleConditionOperator {
    UNKNOWN_SIMPLE_OP = "UNKNOWN_SIMPLE_OP",
    EQUAL = "EQUAL"
}
/** @enumType */
export type SimpleConditionOperatorWithLiterals = SimpleConditionOperator | 'UNKNOWN_SIMPLE_OP' | 'EQUAL';
export interface JoinedCondition {
    /** The operator that should be used when evaluating the condition */
    op?: JoinedConditionOperatorWithLiterals;
    /** The conditions that should be evaluated, and then joined using the operator provided */
    conditions?: ConditionType[];
}
export declare enum JoinedConditionOperator {
    UNKNOWN_JOIN_OP = "UNKNOWN_JOIN_OP",
    OR = "OR",
    AND = "AND"
}
/** @enumType */
export type JoinedConditionOperatorWithLiterals = JoinedConditionOperator | 'UNKNOWN_JOIN_OP' | 'OR' | 'AND';
export interface EnvironmentCondition extends EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
/** @oneof */
export interface EnvironmentConditionConditionOneOf {
    experimentCondition?: ExperimentCondition;
}
export interface ExperimentCondition {
    spec?: string;
    fallbackValue?: string;
    expectedValue?: string;
}
export interface Condition {
    /** The unique identifier of the condition model. Indicates which actions the condition is working on */
    conditionModelId?: string;
    /** The operator that should be evaluated */
    operator?: ConditionOperator;
}
export interface ConditionOperator extends ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
/** @oneof */
export interface ConditionOperatorOperatorsOneOf {
    /** Comparison of equality - will be evaluated to true if the given parties are equal */
    equals?: EqualOperator;
    /** Regex operator - will be evaluated to true if the given value matches the provided regex */
    like?: LikeOperator;
    /** Petri experiment - will be evaluated using petri. */
    experiment?: ExperimentOperator;
    /** Operator that indicates a dependency on another subject being allowed to perform something. */
    dependOn?: DependOnOperator;
}
export interface EqualOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the other side (attribute/value) */
    attrName?: string;
    /** The value to compare to. If the two parties are equal - we will return true. */
    value?: ConditionValue;
}
export interface ConditionValue extends ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
/** @oneof */
export interface ConditionValueValueOneOf {
    /** an attribute. We'll first retrieve the value of the attribute (from the request or from pre-indexed values), and then compare to what it needs to be compared with. */
    attrName?: string;
    /** a value with a string type. Will be compared to the attribute provided, and be true only if they match the operator. */
    stringValue?: string;
    /** a value with a boolean type. Will be compared to the attribute provided, and be true only if they match the operator. */
    boolValue?: boolean;
}
export interface LikeOperator {
    /** The attribute which should be compared. The attribute will be first evaluated to a value, and then compared the regex values provided. */
    attrName?: string;
    /** The regex values which the attribute value should be evaluated on. If the attribute value matches at least one of the regular expressions provided - we will return true */
    values?: string[];
}
export interface ExperimentOperator {
    /** The spec to conduct the experiment on. */
    spec?: string;
    /** The value to use if the experiment could not be conducted */
    fallbackValue?: string;
    /** The expected value of the experiment conduction. If it matches the actual value - true will be returned. Otherwise - false. */
    expectedValue?: string;
}
/** Implies that the policy takes affect only if the depend on subject is permitted as well. */
export interface DependOnOperator {
    /** The subject on which the current entry depends on. If the subject is allowed to perform what the query was about - the condition will be evaluated to true. Otherwise - false */
    dependOnSubject?: Subject;
}
export interface PolicyUnassigned {
    subject?: Subject;
    assignment?: PolicyAssignment[];
}
export interface PolicyAssignmentUpdated {
    subject?: Subject;
    fromAssignment?: PolicyAssignment[];
    toAssignment?: PolicyAssignment[];
}
export interface Empty {
}
export interface PolicyAuthorizationDataUpdated {
    policyId?: string;
    fromPolicyStatements?: PolicyStatement[];
    toPolicyStatements?: PolicyStatement[];
    policyType?: PolicyTypeWithLiterals;
    policyOwner?: PolicyOwner;
}
export interface PolicyStatement {
    /** @readonly */
    id?: string | null;
    permissions?: string[];
    scopes?: string[];
    effect?: EffectWithLiterals;
    condition?: PolicyCondition;
}
export declare enum Effect {
    UNKNOWN_EFFECT = "UNKNOWN_EFFECT",
    ALLOW = "ALLOW",
    DENY = "DENY"
}
/** @enumType */
export type EffectWithLiterals = Effect | 'UNKNOWN_EFFECT' | 'ALLOW' | 'DENY';
export declare enum PolicyType {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    PREDEFINED = "PREDEFINED",
    CUSTOM = "CUSTOM",
    INLINE_CUSTOM = "INLINE_CUSTOM"
}
/** @enumType */
export type PolicyTypeWithLiterals = PolicyType | 'UNKNOWN_STATUS' | 'PREDEFINED' | 'CUSTOM' | 'INLINE_CUSTOM';
export interface PolicyOwner {
    type?: PolicyOwnerTypeWithLiterals;
    id?: string;
}
export declare enum PolicyOwnerType {
    UNKNOWN_TYPE = "UNKNOWN_TYPE",
    WIX = "WIX",
    WIX_ACCOUNT = "WIX_ACCOUNT"
}
/** @enumType */
export type PolicyOwnerTypeWithLiterals = PolicyOwnerType | 'UNKNOWN_TYPE' | 'WIX' | 'WIX_ACCOUNT';
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /** Event ID. With this ID you can easily spot duplicated events and ignore them. */
    id?: string;
    /**
     * Fully Qualified Domain Name of an entity. This is a unique identifier assigned to the API main business entities.
     * For example, `wix.stores.catalog.product`, `wix.bookings.session`, `wix.payments.transaction`.
     */
    entityFqdn?: string;
    /**
     * Event action name, placed at the top level to make it easier for users to dispatch messages.
     * For example: `created`/`updated`/`deleted`/`started`/`completed`/`email_opened`.
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example, `2020-04-26T13:57:50.699Z`. */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number that indicates the order of updates to an entity. For example, if an entity was updated at 16:00 and then again at 16:01, the second update will always have a higher sequence number.
     * You can use this number to make sure you're handling updates in the right order. Just save the latest sequence number on your end and compare it to the one in each new message. If the new message has an older (lower) number, you can safely ignore it.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted. */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
